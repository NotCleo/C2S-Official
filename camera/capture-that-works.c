#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <errno.h>

// ==========================================
// 1. HARDWARE MAPPING
// ==========================================
#define SPI_PHYS_BASE   0x10115000UL 
#define I2C_PHYS_BASE   0x10116000UL
#define MAP_SIZE        4096UL
#define MAP_MASK        (MAP_SIZE - 1)

volatile uint32_t *spi_base_virt = NULL;
volatile uint32_t *i2c_base_virt = NULL;

#define SPI_REG(offset)  (*(volatile uint32_t *)((uint8_t *)spi_base_virt + (offset)))
#define I2C_REG(offset)  (*(volatile uint32_t *)((uint8_t *)i2c_base_virt + (offset)))

// ==========================================
// 2. CONSTANTS
// ==========================================
#define ARDUCHIP_TEST1       0x00
#define ARDUCHIP_FIFO        0x04
#define ARDUCHIP_TRIG        0x41
#define CAP_DONE_MASK        0x08
#define ARDUCHIP_FIFO_SIZE1  0x42
#define ARDUCHIP_FIFO_SIZE2  0x43
#define ARDUCHIP_FIFO_SIZE3  0x44
#define BURST_FIFO_READ      0x3C
#define OV2640_ADDR          0x30

// ==========================================
// 3. UTILITIES
// ==========================================
void *map_physical_memory(uint32_t phys_addr) {
    int mem_fd = open("/dev/mem", O_RDWR | O_SYNC);
    if (mem_fd == -1) { perror("Error opening /dev/mem"); exit(EXIT_FAILURE); }
    void *mapped_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, mem_fd, phys_addr & ~MAP_MASK);
    if (mapped_base == MAP_FAILED) { perror("Error mapping memory"); close(mem_fd); exit(EXIT_FAILURE); }
    close(mem_fd);
    return (void *)((uint8_t *)mapped_base + (phys_addr & MAP_MASK));
}

// ==========================================
// 4. LOW-LEVEL DRIVERS (BLIND MODE)
// ==========================================

void spi_init() {
    SPI_REG(0x40) = 0x0A;       
    usleep(1000);
    SPI_REG(0x60) = 0x186;      
    SPI_REG(0x70) = 0xFFFFFFFF; 
}

uint8_t spi_transfer(uint8_t data) {
    SPI_REG(0x68) = data;       
    SPI_REG(0x60) &= ~0x100;    
    
    // Safety timeout loop for SPI
    int timeout = 0;
    while((SPI_REG(0x64) & 0x01) != 0) {
        if(++timeout > 100000) break; // Break if stuck
    }
    return (uint8_t)SPI_REG(0x6C); 
}

void arducam_write_reg(uint8_t addr, uint8_t data) {
    SPI_REG(0x70) = 0xFFFFFFFE; 
    spi_transfer(addr | 0x80);
    spi_transfer(data);
    SPI_REG(0x70) = 0xFFFFFFFF; 
    usleep(100);
}

uint8_t arducam_read_reg(uint8_t addr) {
    SPI_REG(0x70) = 0xFFFFFFFE; 
    spi_transfer(addr & 0x7F);
    uint8_t val = spi_transfer(0x00);
    SPI_REG(0x70) = 0xFFFFFFFF; 
    usleep(100);
    return val;
}

// --- I2C (BLIND MODE - NO CHECKS) ---
void i2c_init() {
    I2C_REG(0x40) = 0x0A; 
    usleep(1000);
    I2C_REG(0x100) = 0x01; 
}

void i2c_write_reg(uint8_t reg, uint8_t val) {
    // We do NOT check the status register here.
    // We just write and wait blindly.
    
    // 1. Reset/Enable
    I2C_REG(0x40) = 0x0A;
    usleep(200); 
    I2C_REG(0x100) = 0x01;

    // 2. Write Data
    I2C_REG(0x108) = 0x100 | (OV2640_ADDR << 1); 
    I2C_REG(0x108) = reg;                        
    I2C_REG(0x108) = 0x200 | val;                

    // 3. Blind Wait (5000us = 5ms is plenty for 100kHz I2C)
    usleep(5000); 
}

// ==========================================
// 5. CONFIGURATION ARRAYS (OV2640 JPEG)
// ==========================================
const uint8_t OV2640_JPEG_INIT[][2] = {
    {0xff, 0x00}, {0x2c, 0xff}, {0x2e, 0xdf}, {0xff, 0x01}, {0x3c, 0x32}, {0x11, 0x00},
    {0x09, 0x02}, {0x04, 0x28}, {0x13, 0xe5}, {0x14, 0x48}, {0x2c, 0x0c}, {0x33, 0x78},
    {0x3a, 0x33}, {0x3b, 0xfb}, {0x3e, 0x00}, {0x43, 0x11}, {0x16, 0x10}, {0x39, 0x92},
    {0x35, 0xda}, {0x22, 0x1a}, {0x37, 0xc3}, {0x23, 0x00}, {0x34, 0xc0}, {0x36, 0x1a},
    {0x06, 0x88}, {0x07, 0xc0}, {0x0d, 0x87}, {0x0e, 0x41}, {0x4c, 0x00}, {0x48, 0x00},
    {0x5b, 0x00}, {0x42, 0x03}, {0x4a, 0x81}, {0x21, 0x99}, {0x24, 0x40}, {0x25, 0x38},
    {0x26, 0x82}, {0x5c, 0x00}, {0x63, 0x00}, {0x61, 0x70}, {0x62, 0x80}, {0x7c, 0x05},
    {0x20, 0x80}, {0x28, 0x30}, {0x6c, 0x00}, {0x6d, 0x80}, {0x6e, 0x00}, {0x70, 0x02},
    {0x71, 0x94}, {0x73, 0xc1}, {0x12, 0x40}, {0x17, 0x11}, {0x18, 0x43}, {0x19, 0x00},
    {0x1a, 0x4b}, {0x32, 0x09}, {0x37, 0xc0}, {0x4f, 0x60}, {0x50, 0xa8}, {0x6d, 0x00},
    {0x3d, 0x38}, {0x46, 0x3f}, {0x4f, 0x60}, {0x0c, 0x3c}, {0xff, 0x00}, {0xe5, 0x7f},
    {0xf9, 0xc0}, {0x41, 0x24}, {0xe0, 0x14}, {0x76, 0xff}, {0x33, 0xa0}, {0x42, 0x20},
    {0x43, 0x18}, {0x4c, 0x00}, {0x87, 0xd5}, {0x88, 0x3f}, {0xd7, 0x03}, {0xd9, 0x10},
    {0xd3, 0x82}, {0xc8, 0x08}, {0xc9, 0x80}, {0x7c, 0x00}, {0x7d, 0x00}, {0x7c, 0x03},
    {0x7d, 0x48}, {0x7d, 0x48}, {0x7c, 0x08}, {0x7d, 0x20}, {0x7d, 0x10}, {0x7d, 0x0e},
    {0x90, 0x00}, {0x91, 0x0e}, {0x91, 0x1a}, {0x91, 0x31}, {0x91, 0x5a}, {0x91, 0x69},
    {0x91, 0x75}, {0x91, 0x7e}, {0x91, 0x88}, {0x91, 0x8f}, {0x91, 0x96}, {0x91, 0xa3},
    {0x91, 0xaf}, {0x91, 0xc4}, {0x91, 0xd7}, {0x91, 0xe8}, {0x91, 0x20}, {0x92, 0x00},
    {0x93, 0x06}, {0x93, 0xe3}, {0x93, 0x05}, {0x93, 0x05}, {0x93, 0x00}, {0x93, 0x04},
    {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00},
    {0x93, 0x00}, {0x96, 0x00}, {0x97, 0x08}, {0x97, 0x19}, {0x97, 0x02}, {0x97, 0x0c},
    {0x97, 0x24}, {0x97, 0x30}, {0x97, 0x28}, {0x97, 0x26}, {0x97, 0x02}, {0x97, 0x98},
    {0x97, 0x80}, {0x97, 0x00}, {0x97, 0x00}, {0xc3, 0xed}, {0xa4, 0x00}, {0xa8, 0x00},
    {0xc5, 0x11}, {0xc6, 0x51}, {0xbf, 0x80}, {0xc7, 0x10}, {0xb6, 0x66}, {0xb8, 0xa5},
    {0xb7, 0x64}, {0xb9, 0x7c}, {0xb3, 0xaf}, {0xb4, 0x97}, {0xb5, 0xff}, {0xb0, 0xc5},
    {0xb1, 0x94}, {0xb2, 0x0f}, {0xc4, 0x5c}, {0xc0, 0x64}, {0xc1, 0x4b}, {0x8c, 0x00},
    {0x86, 0x3d}, {0x50, 0x00}, {0x51, 0xc8}, {0x52, 0x96}, {0x53, 0x00}, {0x54, 0x00},
    {0x55, 0x00}, {0x5a, 0xc8}, {0x5b, 0x96}, {0x5c, 0x00}, {0xd3, 0x00}, {0xc3, 0xed},
    {0x7f, 0x00}, {0xda, 0x00}, {0xe5, 0x1f}, {0xe1, 0x67}, {0xe0, 0x00}, {0xdd, 0x7f},
    {0x05, 0x00}, {0x12, 0x40}, {0xd3, 0x04}, {0xc0, 0x16}, {0xc1, 0x12}, {0x8c, 0x00},
    {0x86, 0x3d}, {0x50, 0x00}, {0x51, 0x2c}, {0x52, 0x24}, {0x53, 0x00}, {0x54, 0x00},
    {0x55, 0x00}, {0x5a, 0x2c}, {0x5b, 0x24}, {0x5c, 0x00}, {0xff, 0xff}
};

const uint8_t OV2640_320x240_JPEG[][2] = {
    {0xff, 0x01}, {0x12, 0x40}, {0x17, 0x11}, {0x18, 0x43}, {0x19, 0x00}, {0x1a, 0x4b},
    {0x32, 0x09}, {0x4f, 0xca}, {0x50, 0xa8}, {0x5a, 0x23}, {0x6d, 0x00}, {0x39, 0x12},
    {0x35, 0xda}, {0x22, 0x1a}, {0x37, 0xc3}, {0x23, 0x00}, {0x34, 0xc0}, {0x36, 0x1a},
    {0x06, 0x88}, {0x07, 0xc0}, {0x0d, 0x87}, {0x0e, 0x41}, {0x4c, 0x00}, {0xff, 0x00},
    {0xe0, 0x04}, {0xc0, 0x64}, {0xc1, 0x4b}, {0x86, 0x35}, {0x50, 0x89}, {0x51, 0xc8},
    {0x52, 0x96}, {0x53, 0x00}, {0x54, 0x00}, {0x55, 0x00}, {0x57, 0x00}, {0x5a, 0x50},
    {0x5b, 0x3c}, {0x5c, 0x00}, {0xe0, 0x00}, {0xff, 0xff}
};

void sensor_write_array(const uint8_t data[][2]) {
    int i = 0;
    while (1) {
        uint8_t reg = data[i][0];
        uint8_t val = data[i][1];
        if (reg == 0xFF && val == 0xFF) break;
        i2c_write_reg(reg, val);
        i++;
    }
}

// ==========================================
// 6. MAIN EXECUTION
// ==========================================
int main() {
    printf("[INIT] Mapping Physical Memory...\n");
    spi_base_virt = (volatile uint32_t *)map_physical_memory(SPI_PHYS_BASE);
    i2c_base_virt = (volatile uint32_t *)map_physical_memory(I2C_PHYS_BASE);

    spi_init();
    i2c_init();

    // 1. Check SPI
    printf("[STEP 1] Check SPI... ");
    arducam_write_reg(ARDUCHIP_TEST1, 0x55);
    uint8_t test = arducam_read_reg(ARDUCHIP_TEST1);
    if(test != 0x55) { printf("FAIL (0x%02X)\n", test); return -1; }
    printf("PASS\n");

    // 2. Configure Sensor
    printf("[STEP 2] Configuring OV2640... ");
    i2c_write_reg(0xFF, 0x01); 
    i2c_write_reg(0x12, 0x80); 
    usleep(200000); 
    sensor_write_array(OV2640_JPEG_INIT);
    sensor_write_array(OV2640_320x240_JPEG);
    printf("DONE.\n");

    // 3. Trigger Capture
    printf("[STEP 3] Triggering Capture...\n");
    arducam_write_reg(ARDUCHIP_FIFO, 0x01); 
    arducam_write_reg(ARDUCHIP_FIFO, 0x02); 

    int attempts = 0;
    while (!(arducam_read_reg(ARDUCHIP_TRIG) & CAP_DONE_MASK)) {
        usleep(100000);
        printf("."); fflush(stdout);
        if(++attempts > 500) { printf("\n[ERROR] Timeout!\n"); return -1; }
    }
    printf("\n[SUCCESS] Capture Complete.\n");

    // 4. Read Size
    uint32_t len1 = arducam_read_reg(ARDUCHIP_FIFO_SIZE1);
    uint32_t len2 = arducam_read_reg(ARDUCHIP_FIFO_SIZE2);
    uint32_t len3 = arducam_read_reg(ARDUCHIP_FIFO_SIZE3) & 0x7F;
    uint32_t length = ((len3 << 16) | (len2 << 8) | len1) & 0x07FFFFF;

    printf("[STEP 4] Image Size: %d bytes\n", (int)length);
    if (length == 0 || length > 400000) { printf("[ERROR] Invalid Size.\n"); return -1; }

    // 5. Save to BIN File
    printf("[STEP 5] Saving to 'image.bin'...\n");
    FILE *fp = fopen("image.bin", "wb");
    if (!fp) { perror("File open failed"); return -1; }

    SPI_REG(0x70) = 0xFFFFFFFE; // CS Assert
    spi_transfer(BURST_FIFO_READ);
    
    // DUMMY BYTE
    spi_transfer(0x00); 

    for (uint32_t i = 0; i < length; i++) {
        uint8_t byte = spi_transfer(0x00);
        fputc(byte, fp);
        if (i % 4096 == 0) { printf("."); fflush(stdout); }
    }
    
    SPI_REG(0x70) = 0xFFFFFFFF; // CS Deassert
    fclose(fp);

    printf("\n[DONE] Saved to image.bin\n");
    return 0;
}
